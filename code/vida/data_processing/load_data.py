import numpy as np
import copy


# load dataset generated by Multistrand
def loadtrj(f,FINAL_STRUCTURE,type):
    """load text data and split it into individual trajectory 
    with seperated structure, time, and energy

    Args:
        f: text file with trajectory dp notation, time, energy, and if paired (1) or not (0)
            eg. '..((((....)))).', 't=0.000000103', 'seconds, dG=  0.26 kcal/mol\n', "0"
        FINAL_STRUCTURE: final state structure, eg. "..((((....))))."
        type: 'Single' or 'Multiple' mode
    Returns:
        [list]: dot-parenthesis notation, time floats, energy floats
            eg. ['...............', 0.0, 0.0, 0.0]
    """
    TRAJ=[];i=0;SIM=[]
    
    for s in f:
        ss = s.split(" ")
        s_dotparan=ss[0] # dp notation
        s_time = float(ss[1].split("=",1)[1]) # simulation time
        s_energy = float(ss[3].split("=")[1].split("kcal")[0]) # energy
        s_pair = int(ss[-1]) # paired or not
        TRAJ.append([s_dotparan,s_time,s_energy,s_pair])

        if type == "Single":
            if s_dotparan == FINAL_STRUCTURE: # split to individual trajectory
                SIM.append(TRAJ)
                TRAJ = []
                
    if type == "Multiple":
        SIM = TRAJ
    return SIM


# load multiple trajectories from multiple files
def load_multitrj(folder_name,FINAL_STRUCTURE,num_files):
    # load text file
    SIMS = []; SIMS_concat = []
    for i in range(num_files):
        STR_name = "{}_{}.txt".format(folder_name,i) # PT0
        f = open(STR_name, 'r') # PT0
        SIM = loadtrj(f,FINAL_STRUCTURE,type="Multiple")
        SIMconcat = concat_helix_structures(SIM) 
        SIMS += SIM
        SIMS_concat += SIMconcat
        
    return SIMS,np.array(SIMS),SIMS_concat


# convert concantenate two individual structures to one structure
def concat_helix_structures(SIM):
    """concatenate two individual structures to one structure
    Args:
        SIM: list of individual structures
    Returns:
        SIM_concat: concatenated structure
    """
    SIM_concat = copy.deepcopy(SIM)
    for i in range(len(SIM)):
        # if i == 0:
        #     SIM_concat[i][0] *=2 
        # else:
        #     SIM_concat[i][0] = SIM[i][0].replace("+","")
        SIM_concat[i][0] = SIM[i][0].replace("+","")
    return SIM_concat


# assign each states with their labels
def label_structures(SIM,indices):
    """label the visited states of the trajectory 
            based on their unique structure indices
    Args:
        SIM: fully states info of the trajectory
    Returns:
        SIM_dict: fully labeled cstates of the trajectory
    """
    # add a nan column to full states array
    new_col = np.empty(len(np.array(SIM)))
    new_col.fill(np.nan)
    SIM_dict = np.c_[np.array(SIM),new_col]
    # get unique structures
    SIM_dict_uniq = SIM_dict[indices]
    # label the states with its corresponding unique structure indices
    for i in range(len(SIM_dict_uniq)):
        temp = SIM_dict[:,0] == SIM_dict_uniq[i,0]
        indx = np.argwhere(temp==True)
        SIM_dict[indx,-1] = i
    return SIM_dict