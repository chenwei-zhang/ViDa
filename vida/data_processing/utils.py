import numpy as np
import copy


# load dataset generated by Multistrand
def read_1trj(f):
    """load text data and split it into individual trajectory 
    with seperated structure, time, and energy

    Args:
        f: text file with trajectory dp notation, time, energy, and if paired (1) or not (0)
            eg. '..((((....)))).', 't=0.000000103', 'seconds, dG=  0.26 kcal/mol\n', "0"
        FINAL_STRUCTURE: final state structure, eg. "..((((....))))."
        type: 'Single' or 'Multiple' mode
    Returns:
        [list]: dot-parenthesis notation, time floats, energy floats, paired or not
            eg. ['...............', 0.0, -12.0, 1]
    """
    S_dp = []; S_time = []; S_energy = []; S_pair = []
    
    for s in f:
        ss = s.split(" ")
        s_dp=ss[0] # dp notation
        s_time = float(ss[1].split("=",1)[1]) # simulation time
        s_energy = float(ss[3].split("=")[1].split("kcal")[0]) # energy
        s_pair = int(ss[-1]) # paired or not
        
        S_dp.append(s_dp)
        S_time.append(s_time)
        S_energy.append(s_energy)
        S_pair.append(s_pair)
        
    return [S_dp,S_time,S_energy,S_pair]


# load multiple trajectories from multiple files
def read_Gao(fpath,rxn,num_files=100):
    trajs_states, trajs_times, trajs_energies, trajs_pairs = [],[],[],[]
    
    for i in range(num_files):
        STR_name = f"{fpath}/{rxn}/{rxn}-{i}.txt"
        f = open(STR_name, 'r') 
        TRJ = read_1trj(f)
        trajs_states.append(TRJ[0])
        trajs_times.append(TRJ[1])
        trajs_energies.append(TRJ[2])
        trajs_pairs.append(TRJ[3])
    
    trajs_states = np.array(trajs_states, dtype=object)
    trajs_times = np.array(trajs_times, dtype=object)
    trajs_energies = np.array(trajs_energies, dtype=object)
    trajs_pairs = np.array(trajs_pairs, dtype=object)
        
    return trajs_states, trajs_times, trajs_energies, trajs_pairs


# convert concantenate two individual structures to one structure 
def process_gao(dp_og):
    dp = copy.deepcopy(dp_og)
    for i in range(len(dp)):   
        dp[i] = dp[i].replace("+","")
    
    return dp


# convert concantenate two individual structures to one structure, and pair or not
def process_hata(dp_og):
    dp = copy.deepcopy(dp_og)
    dp_pair = []
    for i in range(len(dp)):
        if "&" in dp[i]:
            dp[i] = dp[i].replace("&","")
            dp_pair.append(0)
            
        if "+" in dp[i]:
            dp[i] = dp[i].replace("+","")
            dp_pair.append(1)
            
    return np.array(dp), np.array(dp_pair)


# cooncatanate all sturcutres for Gao dataset: 
def concat_gao(states, times, energies, pairs):
    
    SIMS_dp, SIMS_dp_og, SIMS_pair, SIMS_G, SIMS_T = [],[],[],[],[]
    
    for i in range(len(states)):
        sims_dp = process_gao(states[i])
        
        SIMS_dp.append(sims_dp)
        SIMS_dp_og.append(states[i])
        SIMS_T.append(times[i])
        SIMS_G.append(energies[i])
        SIMS_pair.append(pairs[i])
    
    SIMS_dp = np.concatenate(SIMS_dp)
    SIMS_dp_og = np.concatenate(SIMS_dp_og)
    SIMS_pair = np.concatenate(SIMS_pair)
    SIMS_G = np.concatenate(SIMS_G)
    SIMS_T = np.concatenate(SIMS_T)
        
    return SIMS_dp, SIMS_dp_og, SIMS_pair, SIMS_G, SIMS_T


# cooncatanate all sturcutres for Hata dataset:: 
def concat_hata(states, times, energies):
    
    SIMS_dp, SIMS_dp_og, SIMS_pair, SIMS_G, SIMS_T = [],[],[],[],[]
    
    for i in range(len(states)):
        sims_dp, sims_pair = process_hata(states[i])

        SIMS_dp.append(sims_dp)
        SIMS_dp_og.append(states[i])
        SIMS_pair.append(sims_pair)
        SIMS_G.append(energies[i])
        SIMS_T.append(times[i])
    
    SIMS_dp = np.concatenate(SIMS_dp)
    SIMS_dp_og = np.concatenate(SIMS_dp_og)
    SIMS_pair = np.concatenate(SIMS_pair)
    SIMS_G = np.concatenate(SIMS_G)
    SIMS_T = np.concatenate(SIMS_T)
        
    return SIMS_dp, SIMS_dp_og, SIMS_pair, SIMS_G, SIMS_T


# get the unique structures and their corresponding indices
def get_uniq(SIMS_dp, SIMS_dp_og, SIMS_pair, SIMS_G):
    
    indices_S = np.unique(SIMS_dp,return_index=True)[1]
    
    SIMS_dp_uniq = SIMS_dp[indices_S]
    SIMS_dp_og_uniq = SIMS_dp_og[indices_S]
    SIMS_pair_uniq = SIMS_pair[indices_S]
    SIMS_G_uniq = SIMS_G[indices_S]
        
    # find index to recover to all data from unique data
    coord_id_S = np.empty(len(SIMS_dp))
    for i in range(len(SIMS_dp_uniq)):
        temp = SIMS_dp == SIMS_dp_uniq[i]
        indx = np.argwhere(temp==True)
        coord_id_S[indx] = i
    coord_id_S = coord_id_S.astype(int)

    return SIMS_dp_uniq, SIMS_dp_og_uniq, SIMS_pair_uniq, SIMS_G_uniq, indices_S, coord_id_S


# label the structural types
def label_struc(trajs_types, SIMS_dp_og_uniq):
    
    SIMS_type_uniq = []
    
    for i in range(len(SIMS_dp_og_uniq)):
        SIMS_type_uniq.append(trajs_types[SIMS_dp_og_uniq[i]])
    SIMS_type_uniq = np.array(SIMS_type_uniq)
    
    return SIMS_type_uniq
    
